var documenterSearchIndex = {"docs":
[{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This page collects a few examples for using ImplicitGeometries.jl.","category":"page"},{"location":"examples/#Smooth-boolean-operations","page":"Examples","title":"Smooth boolean operations","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The following constructs the canonical geometry showcasing boolean operations on primitive geometries. Here, we will use the smooth counterparts of the standard boolean operations. The factor k controls the smoothness.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using ImplicitGeometries\n\nk = 0.1; # smoothness factor\nb1 = Box(; w=2.0, h=2.0, d=2.0)\ns1 = Sphere(; r=1.3)\ni1 = SmoothIntersection(s1, b1; k = k)\nc1 = Cylinder(; h = 2.0, r = 0.8)\nc2 = Rotation(Cylinder(; h = 2.0, r = 0.8); ϕ = π/2, θ = 0.0, ψ = 0.0)\nc3 = Rotation(Cylinder(; h = 2.0, r = 0.8); ϕ = 0.0, θ = 0.0, ψ = π/2)\nu1 = SmoothUnion(c1, c2; k = k)\nu2 = SmoothUnion(u1, c3; k = k)\ns2 = SmoothSubtraction(i1, u2; k = k)\ngeometry = Scaling(s2; s=7.0)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To print the construction tree, you can use","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using AbstractTrees\nprint_tree(geometry; maxdepth=10)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The signed distance function can be evaluated at some position p as follows","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using StaticArrays\np = SVector(1.0, 2.0, 3.0)\ngeometry(p)","category":"page"},{"location":"examples/#Visualization","page":"Examples","title":"Visualization","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"ImplicitGeometries.jl only defines implicit geometries. External tools are needed for visualization.","category":"page"},{"location":"examples/#Clip-by-scalar","page":"Examples","title":"Clip by scalar","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"One way to visualize the implicitly defined geometry is to sample the signed distance function on a grid of points and export it a VTK file using WriteVTK.jl.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using WriteVTK\n\n# define sampling grid\nIx = LinRange(-7.5, 7.5, 100)\nIy = LinRange(-7.5, 7.5, 100)\nIz = LinRange(-7.5, 7.5, 100)\nx = Base.Generator(p -> SVector{3}(p), Iterators.product(Ix, Iy, Iz))\n\n# sample geometry, gradient and normals\nϕ = broadcast(geometry, x);\n∇ϕ = broadcast(gradient, x);\nn = broadcast(normal, x);\n\n# export to vtk file\nvtk_grid(\"sdf\", Ix, Iy, Iz) do vtk\n    vtk[\"ϕ\"] = ϕ\n    vtk[\"∇ϕ\"] = ∇ϕ\n    vtk[\"n\"] = n\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To show the zero levelset one can load the VTK file in Paraview and clip the dataset by a scalar (i.e. the signed distance function at zero). The normals can be used to improve the lighting. The final result is shown below.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Smooth boolean operations)","category":"page"},{"location":"examples/#Marching-cubes","page":"Examples","title":"Marching cubes","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Another way, which is arguably faster and gives better results for three-dimensional signed distance functions, is to use MarchingCubes.jl to extract the surface. The normals can be then evaluated on that extracted surface only. Finally, the dataset can be exported using WriteVTK.jl.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Consider the following geometry","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"geometry = Ring(Rectangle(; w=1.0, h=0.05), r=0.2);\ngeometry = Revolution(geometry, o=4.0);\ngeometry = Elongation(geometry; dx=0.5);\nrotated1 = Rotation(geometry; ϕ=π/2);\nrotated2 = Rotation(geometry; ϕ=π/2+π/4);\nrotated3 = Rotation(geometry; ϕ=π/2-π/4);\ngeometry = SmoothUnion(geometry, rotated1);\ngeometry = SmoothUnion(geometry, rotated2);\ngeometry = SmoothUnion(geometry, rotated3);\ngeometry = SmoothUnion(geometry, Translation(Rotation(Ring(Cylinder(; r=0.5, h=2.0); r=0.5); ψ=π/2); dx = -5.0));\ngeometry = SmoothUnion(geometry, Translation(Rotation(Ring(Cylinder(; r=0.5, h=2.0); r=0.5); ψ=π/2); dx = 5.0));\nprint_tree(geometry; maxdepth=10)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The extraction of the surface using marching cubes is straightforward,","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using MarchingCubes, WriteVTK\n\n# define sampling grid\nΩ = ((-7.5, 7.5), (-5.0, 5.0), (-5.0, 5.0))\nIx = LinRange(Ω[1]..., 400)\nIy = LinRange(Ω[2]..., 400)\nIz = LinRange(Ω[3]..., 400)\nx = Base.Generator(p -> SVector{3}(p), Iterators.product(Ix, Iy, Iz))\n\n# sample sdf at the grid of points\nϕ = broadcast(geometry, x);\n\n# initialize and execute marching cubes\nmc = MC(ϕ, Int32, x=Ix, y=Iy, z=Iz);\nmarch(mc)\n\n# collect vertex points, triangualr cells, normals and export\npoints = reduce(hcat, mc.vertices)\ncells = map(t -> MeshCell(VTKCellTypes.VTK_TRIANGLE, t), mc.triangles)\nvtk_grid(\"mc\", points, cells) do vtk\n    vtk[\"n\"] = broadcast(normal, mc.vertices)\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The result is a surface mesh shown below","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Marching cubes surface extraction)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"A key advantage of this approach is that the resulting surface mesh can be imported into MeshLab, which  allows for generating meshes suitable for analysis. This makes it possible to perform both immersed and boundary-fitted finite element computations on geometries modeled with ImplicitGeometries.jl.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Marching cubes surface repaired mesh)","category":"page"},{"location":"examples/#Quadratic-Bezier-curves","page":"Examples","title":"Quadratic Bezier curves","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Two-dimensional signed distance function can be generated from closed multisegment Bezier curves. Consider the following simple airfoil modeled by three quadratic Bezier segments","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"airfoil = [\n           SVector(-1.0,  0.0), SVector( 0.91070,  0.39097), SVector( 1.0,  0.0),\n           SVector( 1.0,  0.0), SVector( 1.06054, -0.26505), SVector( 0.4, -0.1),\n           SVector( 0.4, -0.1), SVector(-0.20900,  0.05217), SVector(-1.0,  0.0)\n];\ngeometry = QuadraticBezier(; v=airfoil)\ngeometry = Ring(geometry; r=0.005)\ngeometry = Rotation(geometry; θ = deg2rad(15))\nprint_tree(geometry)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The result together with the gradient of the signed distance function and the normals is shown below.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Two-dimensional airfoil using Bezier)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The two-dimensional airfoil can be extruded to obtain a three-dimensional airfoil","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"geometry = QuadraticBezier(; v=airfoil)\ngeometry = Rotation(geometry; θ = deg2rad(15))\ngeometry = Scaling(geometry; s=2.0)\ngeometry = Extrusion(geometry; h=5.0)\ngeometry = Ring(geometry; r=0.0125)\nprint_tree(geometry)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Three-dimensional airfoil using extrusion)","category":"page"},{"location":"#ImplicitGeometries.jl","page":"Home","title":"ImplicitGeometries.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package enables construction of implicit geometries by composition of primitive shapes described by signed distance functions. It supports evaluation of gradients and normals of such implicit representations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To represent the construction tree structure, parts of the AbstractTrees.jl interface are implemented.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The articles by Inigo Quilez are a great resource about implicit geometry representations via signed distance functions. This package uses ideas presented in these articles.","category":"page"},{"location":"#ImplicitGeometries.SDF","page":"Home","title":"ImplicitGeometries.SDF","text":"abstract type SDF{Dim,T}\n\nA signed distance function (SDF) represents a geometry implicitly by giving the signed distance from any point in space to the surface of the geometry.\n\nFor a region Ω in ℝⁿ with boundary ∂Ω, the signed distance function ϕ(x) returns:\n\na negative value if x is inside Ω,\nzero if x lies on the boundary ∂Ω,\na positive value if x is outside Ω.\n\nStrictly speaking, the value of ϕ(x) is equal to the shortest (Euclidean) distance to the boundary ∂Ω, with a sign that indicates whether the point is inside or outside the region Ω.\n\nNote, that not all operations implemented in ImplicitGeometries.jl return a true signed distance function. The (Euclidean) distance property is not always preserved.\n\nAll data types subtyping SDF are intended to act as functors. They are callable with a single argument of type SVector{Dim,T} where Dim is the dimension of the domain and T is the used number type.\n\n\n\n\n\n","category":"type"},{"location":"#Shapes","page":"Home","title":"Shapes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Types subtyping Shape serve as building blocks for construction of more complex geometries. These are typically true signed distance functions, i.e. they return the minimal Euclidean distance to the shape boundary.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The following primitive shapes are currently implemented:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Rectangle\nCircle\nBox\nSphere\nCylinder\nQuadraticBezierSegment\nQuadraticBezier\nPolygon","category":"page"},{"location":"#ImplicitGeometries.Shape","page":"Home","title":"ImplicitGeometries.Shape","text":"abstract type Shape{Dim,T} <: SDF{Dim,T}\n\nSigned distance functions describing primitive shapes subtype this.\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitGeometries.Rectangle","page":"Home","title":"ImplicitGeometries.Rectangle","text":"struct Rectangle{T} <: Shape{2,T}\n\nSigned distance function representing a rectangle.\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitGeometries.Rectangle-Union{Tuple{}, Tuple{T}} where T<:Real","page":"Home","title":"ImplicitGeometries.Rectangle","text":"Rectangle(; w::T = 1.0, h::T = 1.0) where {T<:Real}\n\nInitialize Rectangle of width w and height h.\n\n\n\n\n\n","category":"method"},{"location":"#ImplicitGeometries.Circle","page":"Home","title":"ImplicitGeometries.Circle","text":"struct Circle{T} <: Shape{2,T}\n\nSigned distance function representing a circle.\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitGeometries.Circle-Union{Tuple{}, Tuple{T}} where T<:Real","page":"Home","title":"ImplicitGeometries.Circle","text":"Circle(; r::T = 1.0) where {T<:Real}\n\nInitialize Circle with radius r.\n\n\n\n\n\n","category":"method"},{"location":"#ImplicitGeometries.Box","page":"Home","title":"ImplicitGeometries.Box","text":"struct Box{T} <: Shape{3,T}\n\nSigned distance function representing a box.\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitGeometries.Box-Union{Tuple{}, Tuple{T}} where T<:Real","page":"Home","title":"ImplicitGeometries.Box","text":"Box(; w::T = 1.0, h::T = 1.0, d::T = 1.0) where {T<:Real}\n\nInitialize Box of width w, height h and depth d.\n\n\n\n\n\n","category":"method"},{"location":"#ImplicitGeometries.Sphere","page":"Home","title":"ImplicitGeometries.Sphere","text":"struct Sphere{T} <: Shape{3,T}\n\nSigned distance function representing a sphere.\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitGeometries.Sphere-Union{Tuple{}, Tuple{T}} where T<:Real","page":"Home","title":"ImplicitGeometries.Sphere","text":"Sphere(; r::T = 1.0) where {T<:Real}\n\nInitialize Sphere with radius r.\n\n\n\n\n\n","category":"method"},{"location":"#ImplicitGeometries.Cylinder","page":"Home","title":"ImplicitGeometries.Cylinder","text":"struct Cylinder{T} <: Shape{3,T}\n\nSigned distance function representing a cylinder.\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitGeometries.Cylinder-Union{Tuple{}, Tuple{T}} where T<:Real","page":"Home","title":"ImplicitGeometries.Cylinder","text":"Cylinder(; r::T = 1.0) where {T<:Real}\n\nInitialize Cylinder with radius r and height h.\n\n\n\n\n\n","category":"method"},{"location":"#ImplicitGeometries.QuadraticBezierSegment","page":"Home","title":"ImplicitGeometries.QuadraticBezierSegment","text":"struct QuadraticBezierSegment{T} <: Shape{2,T}\n\nSigned distance function defined by a quadratic Bezier segment.\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitGeometries.QuadraticBezierSegment-Union{Tuple{}, Tuple{T}} where T<:Real","page":"Home","title":"ImplicitGeometries.QuadraticBezierSegment","text":"QuadraticBezierSegment(; A::SVector{2,T}, B::SVector{2,T}, C::SVector{2,T}) where {T<:Real}\n\nInitialize QuadraticBezierSegment with control points A, B and C.\n\n\n\n\n\n","category":"method"},{"location":"#ImplicitGeometries.QuadraticBezier","page":"Home","title":"ImplicitGeometries.QuadraticBezier","text":"struct QuadraticBezier{T} <: Shape{2,T}\n\nSigned distance function defined by a quadratic Bezier curve.\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitGeometries.QuadraticBezier-Union{Tuple{}, Tuple{T}} where T<:Real","page":"Home","title":"ImplicitGeometries.QuadraticBezier","text":"QuadraticBezier(; v::Vector{SVector{2,T}}) where {T<:Real}\n\nInitialize QuadraticBezier. The control points for all Bezier segments are collected in the vector v. Typically, the first and the last control point will coincide. The orientation of each segment must be consistent.\n\n\n\n\n\n","category":"method"},{"location":"#ImplicitGeometries.Polygon","page":"Home","title":"ImplicitGeometries.Polygon","text":"struct Polygon{T} <: Shape{2,T}\n\nSigned distance function representing a polygon.\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitGeometries.Polygon-Union{Tuple{}, Tuple{T}} where T<:Real","page":"Home","title":"ImplicitGeometries.Polygon","text":"Polygon(; v::Vector{SVector{2,T}}) where {T<:Real}\n\nInitialize Polygon through points v.\n\n\n\n\n\n","category":"method"},{"location":"#Operations","page":"Home","title":"Operations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Types subtyping Operation are compositions of two or more signed distance functions. Not all operations are described by a true signed distance function.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The following operations are currently implemented:","category":"page"},{"location":"","page":"Home","title":"Home","text":"BooleanUnion, Base.:∪\nBooleanIntersection, Base.:∩\nBooleanSubtraction, Base.:-\nBooleanDifference, Base.:\\\nSmoothMinimum\nSmoothUnion\nSmoothIntersection\nSmoothSubtraction","category":"page"},{"location":"#ImplicitGeometries.Operation","page":"Home","title":"ImplicitGeometries.Operation","text":"abstract type Operation{Dim,T} <: SDF{Dim,T}\n\nOperations on two or more signed distance functions subtype this.\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitGeometries.BooleanOperation","page":"Home","title":"ImplicitGeometries.BooleanOperation","text":"abstract type BooleanOperation{Dim,T} <: Operation{Dim,T}\n\nBoolean operations subtype this.\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitGeometries.BooleanUnion","page":"Home","title":"ImplicitGeometries.BooleanUnion","text":"struct BooleanUnion{Dim,T,S1,S2} <: BooleanOperation{Dim,T}\n\nBoolean union of two signed distance functions.\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitGeometries.BooleanUnion-Union{Tuple{S2}, Tuple{S1}, Tuple{T}, Tuple{Dim}, Tuple{S1, S2}} where {Dim, T, S1<:SDF{Dim, T}, S2<:SDF{Dim, T}}","page":"Home","title":"ImplicitGeometries.BooleanUnion","text":"BooleanUnion(shape1::S1, shape2::S2) where {Dim,T,S1<:SDF{Dim,T},S2<:SDF{Dim,T}}\n\nInitialize signed distance function representing boolean union of shape1 and shape2.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:∪","page":"Home","title":"Base.:∪","text":"Base.:∪(shape1::S1, shape2::S2) where {Dim,T,S1<:SDF{Dim,T},S2<:SDF{Dim,T}}\n\nInitialize signed distance function representing boolean union of shape1 and shape2.\n\n\n\n\n\n","category":"function"},{"location":"#ImplicitGeometries.BooleanIntersection","page":"Home","title":"ImplicitGeometries.BooleanIntersection","text":"struct BooleanIntersection{Dim,T,S1,S2} <: BooleanOperation{Dim,T}\n\nBoolean intersection of two signed distance functions.\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitGeometries.BooleanIntersection-Union{Tuple{S2}, Tuple{S1}, Tuple{T}, Tuple{Dim}, Tuple{S1, S2}} where {Dim, T, S1<:SDF{Dim, T}, S2<:SDF{Dim, T}}","page":"Home","title":"ImplicitGeometries.BooleanIntersection","text":"BooleanIntersection(shape1::S1, shape2::S2) where {Dim,T,S1<:SDF{Dim,T},S2<:SDF{Dim,T}}\n\nInitialize signed distance function representing boolean intersection of shape1 and shape2.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:∩","page":"Home","title":"Base.:∩","text":"Base.:∩(shape1::S1, shape2::S2) where {Dim,T,S1<:SDF{Dim,T},S2<:SDF{Dim,T}}\n\nInitialize signed distance function representing boolean intersection of shape1 and shape2.\n\n\n\n\n\n","category":"function"},{"location":"#ImplicitGeometries.BooleanSubtraction","page":"Home","title":"ImplicitGeometries.BooleanSubtraction","text":"struct BooleanSubtraction{Dim,T,S1,S2} <: BooleanOperation{Dim,T}\n\nBoolean subtraction of two signed distance functions.\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitGeometries.BooleanSubtraction-Union{Tuple{S2}, Tuple{S1}, Tuple{T}, Tuple{Dim}, Tuple{S1, S2}} where {Dim, T, S1<:SDF{Dim, T}, S2<:SDF{Dim, T}}","page":"Home","title":"ImplicitGeometries.BooleanSubtraction","text":"BooleanSubtraction(shape1::S1, shape2::S2) where {Dim,T,S1<:SDF{Dim,T},S2<:SDF{Dim,T}}\n\nInitialize signed distance function representing boolean subtraction of shape1 and shape2.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:-","page":"Home","title":"Base.:-","text":"Base.:-(shape1::S1, shape2::S2) where {Dim,T,S1<:SDF{Dim,T},S2<:SDF{Dim,T}}\n\nInitialize signed distance function representing boolean subtraction of shape1 and shape2.\n\n\n\n\n\n","category":"function"},{"location":"#ImplicitGeometries.BooleanDifference","page":"Home","title":"ImplicitGeometries.BooleanDifference","text":"struct BooleanDifference{Dim,T,S1,S2} <: BooleanOperation{Dim,T}\n\nBoolean difference of two signed distance functions.\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitGeometries.BooleanDifference-Union{Tuple{S2}, Tuple{S1}, Tuple{T}, Tuple{Dim}, Tuple{S1, S2}} where {Dim, T, S1<:SDF{Dim, T}, S2<:SDF{Dim, T}}","page":"Home","title":"ImplicitGeometries.BooleanDifference","text":"BooleanDifference(shape1::S1, shape2::S2) where {Dim,T,S1<:SDF{Dim,T},S2<:SDF{Dim,T}}\n\nInitialize signed distance function representing boolean difference of shape1 and shape2.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:\\","page":"Home","title":"Base.:\\","text":"Base.:\\(shape1::S1, shape2::S2) where {Dim,T,S1<:SDF{Dim,T},S2<:SDF{Dim,T}}\n\nInitialize signed distance function representing boolean difference of shape1 and shape2.\n\n\n\n\n\n","category":"function"},{"location":"#ImplicitGeometries.SmoothMinimum","page":"Home","title":"ImplicitGeometries.SmoothMinimum","text":"struct SmoothMinimum{Dim,T,S1,S2} <: BooleanOperation{Dim,T}\n\nSmooth minimum of two signed distance functions.\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitGeometries.SmoothMinimum-Union{Tuple{S2}, Tuple{S1}, Tuple{T}, Tuple{Dim}, Tuple{S1, S2}} where {Dim, T, S1<:SDF{Dim, T}, S2<:SDF{Dim, T}}","page":"Home","title":"ImplicitGeometries.SmoothMinimum","text":"SmoothMinimum(shape1::S1, shape2::S2; k::T = 0.1) where {Dim,T,S1<:SDF{Dim,T},S2<:SDF{Dim,T}}\n\nInitialize signed distance function representing smooth minimum of shape1 and shape2. The parameter k control the smoothness.\n\n\n\n\n\n","category":"method"},{"location":"#ImplicitGeometries.SmoothUnion","page":"Home","title":"ImplicitGeometries.SmoothUnion","text":"struct SmoothUnion{Dim,T,S1,S2} <: BooleanOperation{Dim,T}\n\nSmooth union of two signed distance functions.\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitGeometries.SmoothUnion-Union{Tuple{S2}, Tuple{S1}, Tuple{T}, Tuple{Dim}, Tuple{S1, S2}} where {Dim, T, S1<:SDF{Dim, T}, S2<:SDF{Dim, T}}","page":"Home","title":"ImplicitGeometries.SmoothUnion","text":"SmoothUnion(shape1::S1, shape2::S2; k::T = 0.1) where {Dim,T,S1<:SDF{Dim,T},S2<:SDF{Dim,T}}\n\nInitialize signed distance function representing smooth union of shape1 and shape2. The parameter k controls the smoothness.\n\n\n\n\n\n","category":"method"},{"location":"#ImplicitGeometries.SmoothIntersection","page":"Home","title":"ImplicitGeometries.SmoothIntersection","text":"struct SmoothIntersection{Dim,T,S1,S2} <: BooleanOperation{Dim,T}\n\nSmooth intersection of two signed distance functions.\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitGeometries.SmoothIntersection-Union{Tuple{S2}, Tuple{S1}, Tuple{T}, Tuple{Dim}, Tuple{S1, S2}} where {Dim, T, S1<:SDF{Dim, T}, S2<:SDF{Dim, T}}","page":"Home","title":"ImplicitGeometries.SmoothIntersection","text":"SmoothIntersection(shape1::S1, shape2::S2; k::T = 0.1) where {Dim,T,S1<:SDF{Dim,T},S2<:SDF{Dim,T}}\n\nInitialize signed distance function representing smooth intersection of shape1 and shape2. The parameter k controls the smoothness.\n\n\n\n\n\n","category":"method"},{"location":"#ImplicitGeometries.SmoothSubtraction","page":"Home","title":"ImplicitGeometries.SmoothSubtraction","text":"struct SmoothSubtraction{Dim,T,S1,S2} <: BooleanOperation{Dim,T}\n\nSmooth subtraction of two signed distance functions.\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitGeometries.SmoothSubtraction-Union{Tuple{S2}, Tuple{S1}, Tuple{T}, Tuple{Dim}, Tuple{S1, S2}} where {Dim, T, S1<:SDF{Dim, T}, S2<:SDF{Dim, T}}","page":"Home","title":"ImplicitGeometries.SmoothSubtraction","text":"SmoothSubtraction(shape1::S1, shape2::S2; k::T = 0.1) where {Dim,T,S1<:SDF{Dim,T},S2<:SDF{Dim,T}}\n\nInitialize signed distance function representing smooth subtraction of shape1 and shape2. The parameter k controls the smoothness.\n\n\n\n\n\n","category":"method"},{"location":"#Transformations","page":"Home","title":"Transformations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Types subtyping Transformation operate on a single signed distance function. Most transformations are described by a true signed distance function.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The following transformations are currently implemented:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Translation\nRotation\nOnion\nRing\nScaling\nElongation\nRevolution\nExtrusion\nBooleanNegative","category":"page"},{"location":"#ImplicitGeometries.Transformation","page":"Home","title":"ImplicitGeometries.Transformation","text":"abstract type Transformation{Dim,T} <: SDF{Dim,T}\n\nTransformations of a signed distance function subtype this.\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitGeometries.Translation","page":"Home","title":"ImplicitGeometries.Translation","text":"struct Translation{Dim,T,S} <: Transformation{Dim,T}\n\nTranslated signed distance function.\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitGeometries.Translation-Union{Tuple{S}, Tuple{T}} where {T, S<:SDF{2, T}}","page":"Home","title":"ImplicitGeometries.Translation","text":"Translation(shape::S; dx::T = 0.0, dy::T = 0.0) where {T,S<:SDF{2,T}}\n\nInitialize Translation from shape. Parameters dx and dy control the translation amount in x and y direction. \n\n\n\n\n\nTranslation(shape::S; dx::T = 0.0, dy::T = 0.0, dz::T = 0.0) where {T,S<:SDF{3,T}}\n\nInitialize Translation from shape. Parameters dx, dy and dz control the translation amount in x, y and z direction. \n\n\n\n\n\n","category":"method"},{"location":"#ImplicitGeometries.Rotation","page":"Home","title":"ImplicitGeometries.Rotation","text":"struct Rotation{Dim,T,S} <: Transformation{Dim,T}\n\nRotated signed distance function.\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitGeometries.Rotation-Union{Tuple{S}, Tuple{T}} where {T, S<:SDF{2, T}}","page":"Home","title":"ImplicitGeometries.Rotation","text":"Rotation(shape::S; θ::T = 0.0, dx::T = 0.0, dy::T = 0.0) where {T,S<:SDF{2,T}}\n\nInitialize Rotation from shape rotated by angle θ. The parameters dx and dy control the center of rotation.\n\n\n\n\n\nRotation(shape::S; ϕ::T = 0.0, θ::T = 0.0, ψ::T = 0.0, dx::T = 0.0, dy::T = 0.0, dz::T = 0.0) where {T,S<:SDF{3,T}}\n\nInitialize Rotation from shape. The parameters ϕ, θ and ψ are rotation angles around the first, second and third axis. The parameters dx, dy and dz control the center of rotation.\n\n\n\n\n\n","category":"method"},{"location":"#ImplicitGeometries.Onion","page":"Home","title":"ImplicitGeometries.Onion","text":"struct Onion{Dim,T,S} <: Transformation{Dim,T}\n\nOnion of a signed distance function.\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitGeometries.Onion-Union{Tuple{S}, Tuple{T}, Tuple{Dim}} where {Dim, T, S<:SDF{Dim, T}}","page":"Home","title":"ImplicitGeometries.Onion","text":"Onion(shape::S; r::T = 0.0) where {T,S<:SDF{2,T}}\n\nInitialize Onion from shape. Parameter r controls the thickness.\n\n\n\n\n\n","category":"method"},{"location":"#ImplicitGeometries.Ring","page":"Home","title":"ImplicitGeometries.Ring","text":"struct Ring{Dim,T,S} <: Transformation{Dim,T}\n\nRing of a signed distance function.\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitGeometries.Ring-Union{Tuple{S}, Tuple{T}, Tuple{Dim}} where {Dim, T, S<:SDF{Dim, T}}","page":"Home","title":"ImplicitGeometries.Ring","text":"Ring(shape::S; r::T = 0.0) where {T,S<:SDF{2,T}}\n\nInitialize Ring from shape. Parameter r controls the offset.\n\n\n\n\n\n","category":"method"},{"location":"#ImplicitGeometries.Scaling","page":"Home","title":"ImplicitGeometries.Scaling","text":"struct Scaling{Dim,T,S} <: Transformation{Dim,T}\n\nScaling of a signed distance function.\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitGeometries.Scaling-Union{Tuple{S}, Tuple{T}, Tuple{Dim}} where {Dim, T, S<:SDF{Dim, T}}","page":"Home","title":"ImplicitGeometries.Scaling","text":"Scaling(shape::S; s::T = 1.0) where {T,S<:SDF{2,T}}\n\nInitialize Scaling from shape. Parameter s controls the scale.\n\n\n\n\n\n","category":"method"},{"location":"#ImplicitGeometries.Elongation","page":"Home","title":"ImplicitGeometries.Elongation","text":"struct Elongation{Dim,T,S} <: Transformation{Dim,T}\n\nElongation of a signed distance function.\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitGeometries.Elongation-Union{Tuple{S}, Tuple{T}} where {T, S<:SDF{3, T}}","page":"Home","title":"ImplicitGeometries.Elongation","text":"Elongation(op::S; dx::T = 0.0, dy::T = 0.0, dz::T = 0.0) where {T,S<:SDF{3,T}}\n\nInitialize Elongation from three dimensional shape. Parameters dx, dy, dz the amount of elongation in x, y and z.\n\n\n\n\n\n","category":"method"},{"location":"#ImplicitGeometries.Revolution","page":"Home","title":"ImplicitGeometries.Revolution","text":"struct Revolution{T,S} <: Transformation{3,T}\n\nRevolution of a two dimensional signed distance function around the origin.\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitGeometries.Revolution-Union{Tuple{S}, Tuple{T}} where {T, S<:SDF{2, T}}","page":"Home","title":"ImplicitGeometries.Revolution","text":"Revolution(op::S; o::T = 1.0) where {T,S<:SDF{2,T}}\n\nInitialize Revolution from two dimensional shape. Parameter o controls the radius of the revolution.\n\n\n\n\n\n","category":"method"},{"location":"#ImplicitGeometries.Extrusion","page":"Home","title":"ImplicitGeometries.Extrusion","text":"struct Extrusion{T,S} <: Transformation{3,T}\n\nExtrusion of a two dimensional signed distance function around the origin.\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitGeometries.Extrusion-Union{Tuple{S}, Tuple{T}} where {T, S<:SDF{2, T}}","page":"Home","title":"ImplicitGeometries.Extrusion","text":"Extrusion(op::S; h::T = 1.0) where {T,S<:SDF{2,T}}\n\nInitialize Extrusion from two dimensional shape. Parameter h controls the height of the extrusion.\n\n\n\n\n\n","category":"method"},{"location":"#ImplicitGeometries.BooleanNegative","page":"Home","title":"ImplicitGeometries.BooleanNegative","text":"struct BooleanNegative{Dim,T,S} <: Transformation{Dim,T}\n\nBoolean negative of a signed distance function.\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitGeometries.BooleanNegative-Union{Tuple{S}, Tuple{T}, Tuple{Dim}} where {Dim, T, S<:SDF{Dim, T}}","page":"Home","title":"ImplicitGeometries.BooleanNegative","text":"BooleanNegative(op::S) where {T,S<:SDF{2,T}}\n\nInitialize BooleanNegative from op.\n\n\n\n\n\n","category":"method"},{"location":"#ImplicitGeometries.:¬","page":"Home","title":"ImplicitGeometries.:¬","text":"¬(shape::S) where {Dim,T,S<:SDF{Dim,T}}\n\nInitialize BooleanNegative from shape.\n\n\n\n\n\n","category":"function"},{"location":"#Gradients","page":"Home","title":"Gradients","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ImplicitGeometries.jl supports evaluation of gradients of signed distance functions. Currently, the gradients in two dimensions are approximated by second order finite differences with a 4-point cross stencil. The gradients in three dimensions are approximated by first order finite differences with a 4-point tetrahedron stencil. The Gradient is a functor similar to SDF. It can be evaluated a some position p.","category":"page"},{"location":"#ImplicitGeometries.Gradient","page":"Home","title":"ImplicitGeometries.Gradient","text":"struct Gradient{Dim,T,S<:SDF{Dim,T}}\n\nGradient of a signed distance function.\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitGeometries.Gradient-Union{Tuple{S}, Tuple{T}, Tuple{Dim}} where {Dim, T, S<:SDF{Dim, T}}","page":"Home","title":"ImplicitGeometries.Gradient","text":"Gradient(shape::S; h::T = 1e-4) where {Dim,T,S<:SDF{Dim,T}}\n\nInitialize Gradient for a signed distance function shape. The parameter h controls the width of the finite difference stencil.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"tip: Automatic differentiation\nAutomatic differentiation can also be used to evaluate gradients of signed distance functions and, depending on the application, might also be preferable to the finite differencing used in Gradient. In the following example we use Zygote.jl to evaluate the gradient using automatic differentiation.julia> using Zygote, StaticArrays\n\njulia> geometry = Ring(Rectangle() - Circle(; r=0.25); r=0.1);\n\njulia> print_tree(geometry)\nRing (r = 0.1)\n└─ BooleanSubtraction\n    ├─ Rectangle (w = 1.0, h = 1.0)\n    └─ Circle (r = 0.25)\n\njulia> Zygote.gradient(geometry, p)[1]\n2-element SVector{2, Float64} with indices SOneTo(2):\n0.7071067811865476\n0.7071067811865476\n\njulia> Gradient(geometry)(p)\n2-element SVector{2, Float64} with indices SOneTo(2):\n0.7071067811870169\n0.7071067811881271Note: ForwardDiff.jl seems to struggle with some signed distance functions.","category":"page"},{"location":"#Normals","page":"Home","title":"Normals","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A normal on the boundary of a region described by a constant levelset of a signed distance function is nothing more than the normalized Gradient evaluated on that boundary. The same approximations as in Gradient are used here.","category":"page"},{"location":"#ImplicitGeometries.Normal","page":"Home","title":"ImplicitGeometries.Normal","text":"struct Normal{Dim,T,S<:SDF{Dim,T}}\n\nVector field of normals of a signed distance function.\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitGeometries.Normal-Union{Tuple{S}, Tuple{T}, Tuple{Dim}} where {Dim, T, S<:SDF{Dim, T}}","page":"Home","title":"ImplicitGeometries.Normal","text":"Normal(shape::S; h::T = 1e-4) where {Dim,T,S<:SDF{Dim,T}}\n\nInitialize Normal for a signed distance function shape. The parameter h controls the width of the finite difference stencil.\n\n\n\n\n\n","category":"method"}]
}
