<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · ImplicitGeometries.jl</title><meta name="title" content="Examples · ImplicitGeometries.jl"/><meta property="og:title" content="Examples · ImplicitGeometries.jl"/><meta property="twitter:title" content="Examples · ImplicitGeometries.jl"/><meta name="description" content="Documentation for ImplicitGeometries.jl."/><meta property="og:description" content="Documentation for ImplicitGeometries.jl."/><meta property="twitter:description" content="Documentation for ImplicitGeometries.jl."/><meta property="og:url" content="https://SuiteSplines.github.io/ImplicitGeometries.jl/examples/"/><meta property="twitter:url" content="https://SuiteSplines.github.io/ImplicitGeometries.jl/examples/"/><link rel="canonical" href="https://SuiteSplines.github.io/ImplicitGeometries.jl/examples/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ImplicitGeometries.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Examples</a><ul class="internal"><li><a class="tocitem" href="#Smooth-boolean-operations"><span>Smooth boolean operations</span></a></li><li><a class="tocitem" href="#Visualization"><span>Visualization</span></a></li><li><a class="tocitem" href="#Quadratic-Bezier-curves"><span>Quadratic Bezier curves</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SuiteSplines/ImplicitGeometries.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SuiteSplines/ImplicitGeometries.jl/blob/main/docs/src/examples.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h1><p>This page collects a few examples for using <code>ImplicitGeometries.jl</code>.</p><h2 id="Smooth-boolean-operations"><a class="docs-heading-anchor" href="#Smooth-boolean-operations">Smooth boolean operations</a><a id="Smooth-boolean-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Smooth-boolean-operations" title="Permalink"></a></h2><p>The following constructs the canonical geometry showcasing boolean operations on primitive geometries. Here, we will use the smooth counterparts of the standard boolean operations. The factor <code>k</code> controls the smoothness.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using ImplicitGeometries</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; k = 0.1; # smoothness factor</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; b1 = Box(; w=2.0, h=2.0, d=2.0)</code><code class="nohighlight hljs ansi" style="display:block;">Box{3, Float64}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; s1 = Sphere(; r=1.3)</code><code class="nohighlight hljs ansi" style="display:block;">Sphere{3, Float64}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; i1 = SmoothIntersection(s1, b1; k = k)</code><code class="nohighlight hljs ansi" style="display:block;">SmoothIntersection{3, Float64}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; c1 = Cylinder(; h = 2.0, r = 0.8)</code><code class="nohighlight hljs ansi" style="display:block;">Cylinder{3, Float64}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; c2 = Rotation(Cylinder(; h = 2.0, r = 0.8); ϕ = π/2, θ = 0.0, ψ = 0.0)</code><code class="nohighlight hljs ansi" style="display:block;">Rotation{3, Float64}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; c3 = Rotation(Cylinder(; h = 2.0, r = 0.8); ϕ = 0.0, θ = 0.0, ψ = π/2)</code><code class="nohighlight hljs ansi" style="display:block;">Rotation{3, Float64}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; u1 = SmoothUnion(c1, c2; k = k)</code><code class="nohighlight hljs ansi" style="display:block;">SmoothUnion{3, Float64}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; u2 = SmoothUnion(u1, c3; k = k)</code><code class="nohighlight hljs ansi" style="display:block;">SmoothUnion{3, Float64}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; s2 = SmoothSubtraction(i1, u2; k = k)</code><code class="nohighlight hljs ansi" style="display:block;">SmoothSubtraction{3, Float64}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; geometry = Scaling(s2; s=7.0)</code><code class="nohighlight hljs ansi" style="display:block;">Scaling{3, Float64}</code></pre><p>To print the construction tree, you can use</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using AbstractTrees</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print_tree(geometry; maxdepth=10)</code><code class="nohighlight hljs ansi" style="display:block;">Scaling (s = 7.0)
└─ SmoothSubtraction
   ├─ SmoothIntersection
   │  ├─ Sphere (r = 1.3)
   │  └─ Box (w = 2.0, h = 2.0, d = 2.0)
   └─ SmoothUnion
      ├─ SmoothUnion
      │  ├─ Cylinder (r = 0.8, h = 2.0)
      │  └─ Rotation (ϕ = 90.0°, θ = 0.0°, ψ = 0.0°, dx = 0.0, dy = 0.0, dz = 0.0)
      │     └─ Cylinder (r = 0.8, h = 2.0)
      └─ Rotation (ϕ = 0.0°, θ = 0.0°, ψ = 90.0°, dx = 0.0, dy = 0.0, dz = 0.0)
         └─ Cylinder (r = 0.8, h = 2.0)</code></pre><p>The signed distance function can be evaluated at some position <code>p</code> as follows</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using StaticArrays</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; p = SVector(1.0, 2.0, 3.0)</code><code class="nohighlight hljs ansi" style="display:block;">3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):
 1.0
 2.0
 3.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; geometry(p)</code><code class="nohighlight hljs ansi" style="display:block;">3.3639320225002107</code></pre><h2 id="Visualization"><a class="docs-heading-anchor" href="#Visualization">Visualization</a><a id="Visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization" title="Permalink"></a></h2><p><code>ImplicitGeometries.jl</code> only defines implicit geometries. External tools are needed for visualization.</p><h3 id="Clip-by-scalar"><a class="docs-heading-anchor" href="#Clip-by-scalar">Clip by scalar</a><a id="Clip-by-scalar-1"></a><a class="docs-heading-anchor-permalink" href="#Clip-by-scalar" title="Permalink"></a></h3><p>One way to visualize the implicitly defined geometry is to sample the signed distance function on a grid of points and export it a VTK file using <a href="https://github.com/JuliaVTK/WriteVTK.jl">WriteVTK.jl</a>.</p><pre><code class="language-julia hljs">using WriteVTK

# define sampling grid
Ix = LinRange(-7.5, 7.5, 100)
Iy = LinRange(-7.5, 7.5, 100)
Iz = LinRange(-7.5, 7.5, 100)
x = Base.Generator(p -&gt; SVector{3}(p), Iterators.product(Ix, Iy, Iz))

# sample geometry, gradient and normals
ϕ = broadcast(geometry, x);
∇ϕ = broadcast(gradient, x);
n = broadcast(normal, x);

# export to vtk file
vtk_grid(&quot;sdf&quot;, Ix, Iy, Iz) do vtk
    vtk[&quot;ϕ&quot;] = ϕ
    vtk[&quot;∇ϕ&quot;] = ∇ϕ
    vtk[&quot;n&quot;] = n
end</code></pre><p>To show the zero levelset one can load the VTK file in <a href="https://www.paraview.org/">Paraview</a> and clip the dataset by a scalar (i.e. the signed distance function at zero). The normals can be used to improve the lighting. The final result is shown below.</p><p><img src="../assets/smooth_boolean_example.png" alt="Smooth boolean operations"/></p><h3 id="Marching-cubes"><a class="docs-heading-anchor" href="#Marching-cubes">Marching cubes</a><a id="Marching-cubes-1"></a><a class="docs-heading-anchor-permalink" href="#Marching-cubes" title="Permalink"></a></h3><p>Another way, which is arguably faster and gives better results for three-dimensional signed distance functions, is to use <a href="https://github.com/JuliaGeometry/MarchingCubes.jl">MarchingCubes.jl</a> to extract the surface. The normals can be then evaluated on that extracted surface only. Finally, the dataset can be exported using <a href="https://github.com/JuliaVTK/WriteVTK.jl">WriteVTK.jl</a>.</p><p>Consider the following geometry</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; geometry = Ring(Rectangle(; w=1.0, h=0.05), r=0.2);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; geometry = Revolution(geometry, o=4.0);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; geometry = Elongation(geometry; dx=0.5);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; rotated1 = Rotation(geometry; ϕ=π/2);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; rotated2 = Rotation(geometry; ϕ=π/2+π/4);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; rotated3 = Rotation(geometry; ϕ=π/2-π/4);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; geometry = SmoothUnion(geometry, rotated1);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; geometry = SmoothUnion(geometry, rotated2);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; geometry = SmoothUnion(geometry, rotated3);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; geometry = SmoothUnion(geometry, Translation(Rotation(Ring(Cylinder(; r=0.5, h=2.0); r=0.5); ψ=π/2); dx = -5.0));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; geometry = SmoothUnion(geometry, Translation(Rotation(Ring(Cylinder(; r=0.5, h=2.0); r=0.5); ψ=π/2); dx = 5.0));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print_tree(geometry; maxdepth=10)</code><code class="nohighlight hljs ansi" style="display:block;">SmoothUnion
├─ SmoothUnion
│  ├─ SmoothUnion
│  │  ├─ SmoothUnion
│  │  │  ├─ SmoothUnion
│  │  │  │  ├─ Elongation (dx = 0.5, dy = 0.0, dz = 0.0)
│  │  │  │  │  └─ Revolution (o = 4.0)
│  │  │  │  │     └─ Ring (r = 0.2)
│  │  │  │  │        └─ Rectangle (w = 1.0, h = 0.05)
│  │  │  │  └─ Rotation (ϕ = 90.0°, θ = 0.0°, ψ = 0.0°, dx = 0.0, dy = 0.0, dz = 0.0)
│  │  │  │     └─ Elongation (dx = 0.5, dy = 0.0, dz = 0.0)
│  │  │  │        └─ Revolution (o = 4.0)
│  │  │  │           └─ Ring (r = 0.2)
│  │  │  │              └─ Rectangle (w = 1.0, h = 0.05)
│  │  │  └─ Rotation (ϕ = 135.0°, θ = 0.0°, ψ = 0.0°, dx = 0.0, dy = 0.0, dz = 0.0)
│  │  │     └─ Elongation (dx = 0.5, dy = 0.0, dz = 0.0)
│  │  │        └─ Revolution (o = 4.0)
│  │  │           └─ Ring (r = 0.2)
│  │  │              └─ Rectangle (w = 1.0, h = 0.05)
│  │  └─ Rotation (ϕ = 45.0°, θ = 0.0°, ψ = 0.0°, dx = 0.0, dy = 0.0, dz = 0.0)
│  │     └─ Elongation (dx = 0.5, dy = 0.0, dz = 0.0)
│  │        └─ Revolution (o = 4.0)
│  │           └─ Ring (r = 0.2)
│  │              └─ Rectangle (w = 1.0, h = 0.05)
│  └─ Translation (dx = -5.0, dy = 0.0, dz = 0.0)
│     └─ Rotation (ϕ = 0.0°, θ = 0.0°, ψ = 90.0°, dx = 0.0, dy = 0.0, dz = 0.0)
│        └─ Ring (r = 0.5)
│           └─ Cylinder (r = 0.5, h = 2.0)
└─ Translation (dx = 5.0, dy = 0.0, dz = 0.0)
   └─ Rotation (ϕ = 0.0°, θ = 0.0°, ψ = 90.0°, dx = 0.0, dy = 0.0, dz = 0.0)
      └─ Ring (r = 0.5)
         └─ Cylinder (r = 0.5, h = 2.0)</code></pre><p>The extraction of the surface using marching cubes is straightforward,</p><pre><code class="language-julia hljs">using MarchingCubes, WriteVTK

# define sampling grid
Ω = ((-7.5, 7.5), (-5.0, 5.0), (-5.0, 5.0))
Ix = LinRange(Ω[1]..., 400)
Iy = LinRange(Ω[2]..., 400)
Iz = LinRange(Ω[3]..., 400)
x = Base.Generator(p -&gt; SVector{3}(p), Iterators.product(Ix, Iy, Iz))

# sample sdf at the grid of points
ϕ = broadcast(geometry, x);

# initialize and execute marching cubes
mc = MC(ϕ, Int32, x=Ix, y=Iy, z=Iz);
march(mc)

# collect vertex points, triangualr cells, normals and export
points = reduce(hcat, mc.vertices)
cells = map(t -&gt; MeshCell(VTKCellTypes.VTK_TRIANGLE, t), mc.triangles)
vtk_grid(&quot;mc&quot;, points, cells) do vtk
    vtk[&quot;n&quot;] = broadcast(normal, mc.vertices)
end</code></pre><p>The result is a surface mesh shown below</p><p><img src="../assets/marching_cubes_example_surface.png" alt="Marching cubes surface extraction"/></p><p>A key advantage of this approach is that the resulting surface mesh can be imported into <a href="https://www.meshlab.net/">MeshLab</a>, which  allows for generating meshes suitable for analysis. This makes it possible to perform both immersed and boundary-fitted finite element computations on geometries modeled with <code>ImplicitGeometries.jl</code>.</p><p><img src="../assets/marching_cubes_example_mesh.png" alt="Marching cubes surface repaired mesh"/></p><h2 id="Quadratic-Bezier-curves"><a class="docs-heading-anchor" href="#Quadratic-Bezier-curves">Quadratic Bezier curves</a><a id="Quadratic-Bezier-curves-1"></a><a class="docs-heading-anchor-permalink" href="#Quadratic-Bezier-curves" title="Permalink"></a></h2><p>Two-dimensional signed distance function can be generated from closed multisegment Bezier curves. Consider the following simple airfoil modeled by three quadratic Bezier segments</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; airfoil = [
                  SVector(-1.0,  0.0), SVector( 0.91070,  0.39097), SVector( 1.0,  0.0),
                  SVector( 1.0,  0.0), SVector( 1.06054, -0.26505), SVector( 0.4, -0.1),
                  SVector( 0.4, -0.1), SVector(-0.20900,  0.05217), SVector(-1.0,  0.0)
       ];</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; geometry = QuadraticBezier(; v=airfoil)</code><code class="nohighlight hljs ansi" style="display:block;">QuadraticBezier{2, Float64}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; geometry = Ring(geometry; r=0.005)</code><code class="nohighlight hljs ansi" style="display:block;">Ring{2, Float64}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; geometry = Rotation(geometry; θ = deg2rad(15))</code><code class="nohighlight hljs ansi" style="display:block;">Rotation{2, Float64}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print_tree(geometry)</code><code class="nohighlight hljs ansi" style="display:block;">Rotation (θ = 15.0°, dx = 0.0, dy = 0.0)
└─ Ring (r = 0.005)
   └─ QuadraticBezier (nseg = 3)</code></pre><p>The result together with the gradient of the signed distance function and the normals is shown below.</p><p><img src="../assets/airfoil2d.png" alt="Two-dimensional airfoil using Bezier"/></p><p>The two-dimensional airfoil can be extruded to obtain a three-dimensional airfoil</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; geometry = QuadraticBezier(; v=airfoil)</code><code class="nohighlight hljs ansi" style="display:block;">QuadraticBezier{2, Float64}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; geometry = Rotation(geometry; θ = deg2rad(15))</code><code class="nohighlight hljs ansi" style="display:block;">Rotation{2, Float64}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; geometry = Scaling(geometry; s=2.0)</code><code class="nohighlight hljs ansi" style="display:block;">Scaling{2, Float64}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; geometry = Extrusion(geometry; h=5.0)</code><code class="nohighlight hljs ansi" style="display:block;">Extrusion{3, Float64}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; geometry = Ring(geometry; r=0.0125)</code><code class="nohighlight hljs ansi" style="display:block;">Ring{3, Float64}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print_tree(geometry)</code><code class="nohighlight hljs ansi" style="display:block;">Ring (r = 0.0125)
└─ Extrusion (h = 5.0)
   └─ Scaling (s = 2.0)
      └─ Rotation (θ = 15.0°, dx = 0.0, dy = 0.0)
         └─ QuadraticBezier (nseg = 3)</code></pre><p><img src="../assets/airfoil3d.png" alt="Three-dimensional airfoil using extrusion"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.13.0 on <span class="colophon-date" title="Friday 4 July 2025 21:51">Friday 4 July 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
